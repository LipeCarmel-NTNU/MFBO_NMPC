clear all; close all; clc

% Add folders and subfolders to path
current_dir = fileparts(mfilename('fullpath'));
addpath(genpath(current_dir))

%% Model
get_par
model = @(x, u) dilution_reduced(0, x, u, par);
ode_opt = odeset('NonNegative', 2:3, 'RelTol', 1e-10, 'AbsTol', 1e-10);

%% Linearization conditions
V = 1;
X = 10;

% Check for controllability
[xss, uss] = find_ss(V, X, par, model, ode_opt);
[A, B] = linearize(xss, uss, model);
controllability = ctrb(A,B);
unco = length(A) - rank(controllability);

%% Targets
Xsp = 20;
Vsp = 1;
[xsp, usp] = find_ss(Vsp, Xsp, par, model, ode_opt);

%% Sampling + simulation settings
Ts = 60/3600;   % hours
Tf = 20;        % hours
x0 = [1 2 0];

%% Optimisation variables (log-space)
theta0 = log([1; 1e3; 1; 1; 1e-2]);

% Bounds in log-space (keeps search numerically sane)
lb = -[6; 6; 6; 6; 6];
ub =  [6; 6; 6; 6; 6];

obj = @(th) lqr_tuning_objective( ...
    th, A, B, Ts, Tf, x0, xsp, usp, model, ode_opt);

opts = optimoptions('fmincon', ...
    ...%'Algorithm', 'sqp', ...
    'UseParallel', true);

[theta_opt, J_opt] = fmincon(obj, theta0, [], [], [], [], lb, ub, [], opts);

%% Construct optimal Q, R and compute K
Q_opt = diag([1, exp(theta_opt(1)), exp(theta_opt(2))]);
R_opt = diag(exp(theta_opt(3:5)));

[K_opt, S_opt, e_opt] = lqrd(A, B, Q_opt, R_opt, Ts); %#ok<ASGLU>

fprintf('\n=== Optimal tuning ===\n');
fprintf('J* = %.6g\n', J_opt);
fprintf('Q = diag([%.6g, %.6g, %.6g])\n', diag(Q_opt));
fprintf('R = diag([%.6g, %.6g, %.6g])\n', diag(R_opt));
disp('Closed-loop discrete eigenvalues (from lqrd output e):');
disp(e_opt(:).');

%% Simulate with optimal gain
[Y, T, U] = LQR_simulation(@(t,x,u) model(x, u), Ts, Tf, x0, K_opt, xsp, usp, ode_opt);

%% Plot
colors = good_colors(3);
figure(2);
tiledlayout(3,1,'TileSpacing','tight','Padding','tight')

for i = 1:3
    nexttile
    plot(T, Y(:,i), '-', 'LineWidth', 3, 'Color', colors(i,:)); hold on
    yline(xsp(i), '--', 'LineWidth', 3, 'Color', 'k')
    grid on; box on
    ylabel(sprintf('x_%d', i))
    if i == 1
        title('States')
        legend({'States','Setpoints'}, 'Location','best', 'Interpreter','latex')
    end
    if i == 3
        xlabel('Time (h)')
    end
end
set_font_size()

%% FUNCTIONS

function J = lqr_tuning_objective(theta, A, B, Ts, Tf, x0, xsp, usp, model, ode_opt)

    % Build diagonal Q, R with positivity by construction
    Q = diag([1, exp(theta(1)), exp(theta(2))]);
    R = diag(exp(theta(3:5)));

    % LQR discrete design
    [K, ~, e] = lqrd(A, B, Q, R, Ts);


    % Closed-loop simulation
    [Y, T, U] = LQR_simulation(@(t,x,u) model(x, u), Ts, Tf, x0, K, xsp, usp, ode_opt);

    % Quadratic cost integrand
    Ex = Y - xsp(:).';
    delta_U = diff(U);

    integrand = zeros(length(T), 1);
    J = 0;
    for k = 2:length(T)
        J = J + Ex(k,:)*eye(length(xsp))*Ex(k,:)' + Eu(k,:)*eye(length(usp))*Eu(k,:)';
    end

    J = trapz(T, integrand);


end


function [Y, T, U] = LQR_simulation(system, Ts, Tf, y0, K, yss, uss, ode_opt)
    num_sim = ceil(Tf/Ts) + 1;

    ny = length(yss);
    nu = length(uss);

    Y = zeros(num_sim, ny);
    U = zeros(num_sim, nu);
    T = zeros(num_sim, 1);

    % Initial
    Y(1, :) = y0(:).';
    T(1) = 0;

    y_current = y0(:).';
    t_current = 0;

    % Store a consistent first input (feedback at t=0)
    ym0 = y_current(:) - yss(:);
    u0 = uss(:) - K*ym0;
    u0 = clamp_u(u0, nu);
    U(1,:) = u0(:).';

    for k = 2:num_sim
        ym = y_current(:).' - yss(:).';
        uk = uss(:) - K*ym(:);
        uk = clamp_u(uk, nu);

        ode_current = @(t, y) system(t, y, uk);

        [t_span, y_span] = ode45(ode_current, [t_current, t_current + Ts], y_current, ode_opt);

        y_current = y_span(end, :);
        y_current(y_current < 0) = 0;
        t_current = t_span(end);

        Y(k, :) = y_current;
        U(k, :) = uk(:).';
        T(k) = t_current;
    end
end

function u = clamp_u(u, nu)
    u = max(u, zeros(nu, 1));
    u = min(u, 0.4*ones(nu, 1));
    if u(1) > 0.4
        u(1) = 0.4;
    end
end


function [xss, uss] = find_ss(V, X, par, model, ode_opt)
    Fin = X * par.Y_XSinv * par.kd / par.Sin; % approximate solution
    var = [Fin 0]; % solve ss for Fin and S
    var_opt = fsolve(@(var) model([V, X, var(2)], [var(1), 0, var(1)]), var);

    Fin = var_opt(1);
    S = var_opt(2);

    uss = [Fin 0 Fin];
    u = uss;

    [~, x] = ode45(@(t,x) model(x, u), [0 10], [V, X, S], ode_opt);
    xss = x(end, :);
end
